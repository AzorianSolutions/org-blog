<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>development &#8211; Azorian Solutions</title>
	<atom:link href="/tag/development/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Elucidation of the intricate</description>
	<lastBuildDate>Mon, 29 Jul 2024 09:48:09 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.4.1</generator>

<image>
	<url>/wp-content/uploads/2022/03/cropped-ms-icon-310x310-1-150x150.png</url>
	<title>development &#8211; Azorian Solutions</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>The Double-Edged Elephant In The Industry</title>
		<link>/software-dev/the-double-edged-elephant-in-the-industry/</link>
					<comments>/software-dev/the-double-edged-elephant-in-the-industry/#respond</comments>
		
		<dc:creator><![CDATA[Matt]]></dc:creator>
		<pubDate>Mon, 29 Jul 2024 09:48:08 +0000</pubDate>
				<category><![CDATA[Software Dev]]></category>
		<category><![CDATA[angular]]></category>
		<category><![CDATA[app]]></category>
		<category><![CDATA[css]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[engineering]]></category>
		<category><![CDATA[frontend]]></category>
		<category><![CDATA[html]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[js]]></category>
		<category><![CDATA[knockout]]></category>
		<category><![CDATA[react]]></category>
		<category><![CDATA[software]]></category>
		<category><![CDATA[vue]]></category>
		<category><![CDATA[web]]></category>
		<category><![CDATA[website]]></category>
		<guid isPermaLink="false">/?p=681</guid>

					<description><![CDATA[I want to preface this piece by saying that this will be somewhat speculative, and there are certainly others much more qualified on the topic than I. I hope to captivate you long enough to draw attention to the elephant in modern web app development, as it relates to refueling the industry with fresh talent. [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>I want to preface this piece by saying that this will be somewhat speculative, and there are certainly others much more qualified on the topic than I. I hope to captivate you long enough to draw attention to the elephant in modern web app development, as it relates to refueling the industry with fresh talent. With that being said, a little background on me.</p>



<p>I&#8217;m Matt, a 37 year old I.T. Professional with a thirst for knowledge and experience, and a work ethic that benefits accordingly. Like many, I got my start with technology very young, when bottlenecks consisted of dial-up connections and CPU speeds. I was infatuated with server and network technology before I was a teen, which evolved into fascination with client &lt;> server applications, most specifically web applications.</p>



<p>By high school, I was freelancing on the side, which evolved into my first full-time position in 2006 as an interactive media &amp; web developer. At this time, it was still normal practice to produce semi-static websites with XHTML 1.1, CSS 2, and vanilla JavaScript (ES3). Mind you, jQuery had just been released that same year, so the agency didn&#8217;t even adopt it for the first year. As if these technologies didn&#8217;t provide enough of a tech rodeo, I was also working heavily in Flash, Flex, and ActionScript 2 / 3.</p>



<p>All of that is to say, I started when websites and web apps were in contrast, incredibly simple with a tiny tech stack. Whether we were building websites and applications in Flex, PHP, ASP.NET C#, or even ColdFusion, the browser tech stack remained rather simple. There would definitely be a handful of small JavaScript libraries as part of the standard foundation, but all in with CSS, would still only represent tens of files in non-media assets. Simply put, the most complicated component of the project was always the backend.</p>



<p>Since my beginnings in this career, I have served in many different roles and garnered vast experience, with a broad lateral reach across common industries such as banking, healthcare, telecommunications, finance, and marketing. In that chaotic, tireless, workaholic fueled road to burn-out, I have had the pleasure of experiencing very exciting evolutions of website design, web application engineering, and infrastructure-as-a-service (IaaS).</p>



<p>After having said all that, hopefully you can appreciate that I have been around to see both before and after what I&#8217;ll dub &#8220;the chaos.&#8221; The chaos as I&#8217;ll refer to it from here on out, is the necessary evil that represents the bittersweet, double-edged sword I referenced in the title. This chaos encompasses the ever-evolving, leading popular pseudo-standard tech stack being used at any given time to create web apps. From what I can tell, the current choice seems to be some variation of Node.js, TypeScript, SCSS / CSS3, Bootstrap / Tailwind, React, and the many libraries that come into play as a result of common app features such as linters, testing, CSS compilers, and state management.</p>



<p>I&#8217;ll be the first to praise much of the current tech stack as one that while highly complex, is a necessary evil to achieve the greatness that is large scale platforms. While I do believe that Facebook as an example is a complete cess pool of wasted energy, I also believe that as a web application, it represents quite an astounding achievement. When considering the problematic past of web browsers, and especially JavaScript, I do believe that for web apps to progress to what they are today, the current tech stack was bound to land where it did. I can still remember clearly some of the monstrosities that I created in the 2000&#8217;s era, that could have been multitudes better, if given the tech stack of today. It should be no wonder why the position of &#8220;web developer&#8221; has largely split into &#8220;frontend&#8221; and &#8220;backend&#8221; developers, as frontend development is now it&#8217;s own beast. I wouldn&#8217;t have concurred with this sentiment fifteen years ago.</p>



<p>Something that I feel is easy for senior engineers to forget as I once did, is that we had a notable advantage over this onslaught of complication. Not only did many of us get to go through the slower transitions that lead to today, but we often had employers that still invested into developing their employees. My experience when I got my first agency job was not astounding, I wouldn&#8217;t even say it was impressive. Yet, this employer took a chance on my ignorant confidence. For that, we were both greatly rewarded over time. Even after a break from frontend for only a few years, I found myself somewhat intimidated with adopting the latest and greatest once again. This is, <strong>the double-edged elephant in the industry</strong>.</p>



<p>Now that the mindset of web tech companies seem to be largely focused on massive scale user adoption, this has dramatically changed the goals of the businesses behind the products. This has essentially moved the entry point goal post to something quite substantial in contrast to my simple beginnings. A sizable portion of these tech companies now seem to only seek senior level resources, or at best, don&#8217;t care to make any investment trade offs with junior level resources, expecting valuable experience for entry level positions. There was once an era of web where the typical job market was fruitful with opportunities at small to medium sized local companies that were just trying to create their own thing. Now, it&#8217;s a far-cry from that, considering that many of these companies no longer exist, and the ones that do, have turned to software-as-a-service (SaaS) solutions to fulfill their needs.</p>



<p>So in closing, this post is to ask the question, to what end? Perhaps this is naive in consideration of the coming AI revolutions. I truly believe, there will be a day that a great deal of this work can and will be largely automated through the use of AI, assuming we can get their without perpetual war destroying our way of life first. I have no idea if that day could be in five years or fifteen, but I do believe it&#8217;s coming. This presumably leaves about one generation left to fill the gap. Is this perhaps a driver, of a seemingly shortsighted bet against refueling an industry with fresh, energetic, and motivated talent? If not, then companies need to get comfortable with investing into junior resources, and not setting perfection as a zero-fail mission. Otherwise, when my era of engineers finish burning out and/or moving on, there will be a huge talent void with ginormous financial stakes teetering on it&#8217;s outcome.</p>
]]></content:encoded>
					
					<wfw:commentRss>/software-dev/the-double-edged-elephant-in-the-industry/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Deploying Docker On Ubuntu 20.04</title>
		<link>/compute-stacks/deploying-docker-on-ubuntu-20-04/</link>
					<comments>/compute-stacks/deploying-docker-on-ubuntu-20-04/#respond</comments>
		
		<dc:creator><![CDATA[Matt]]></dc:creator>
		<pubDate>Sun, 27 Mar 2022 14:39:17 +0000</pubDate>
				<category><![CDATA[Compute Stacks]]></category>
		<category><![CDATA[containers]]></category>
		<category><![CDATA[deployment]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[devops]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[hosting]]></category>
		<category><![CDATA[lxc]]></category>
		<category><![CDATA[podman]]></category>
		<category><![CDATA[virtual machines]]></category>
		<category><![CDATA[virtualization]]></category>
		<category><![CDATA[vms]]></category>
		<guid isPermaLink="false">https://azorian.solutions/?p=508</guid>

					<description><![CDATA[I&#8217;m sure you have heard a reference to containers in the midst of what is a container revolution essentially. Much like when machine virtualization really started to gain a footing, containers are off to a similar start. Given that the focus of this article is not to explain the origin or use cases for containers, [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>I&#8217;m sure you have heard a reference to containers in the midst of what is a container revolution essentially. Much like when machine virtualization really started to gain a footing, containers are off to a similar start. Given that the focus of this article is not to explain the origin or use cases for containers, I will spare a lot of detail explaining all the intricacies. I do however want to provide some brief examples of great use cases for containerized services.</p>



<p>Have you ever been in a position where it was time to upgrade a production service to a new major version but are reluctant to make such a potentially impacting change to your production environment? I would say many have been here a time or two. Since machine virtualization came along, this challenge has somewhat been mitigated through the availability of great virtualization features like snapshots with timely rollbacks and other similar backup solutions. While this approach has proven to be very valuable, it can still yield some undesired down time during the upgrade and/or rollback process depending on your deployment configurations.</p>



<p>Enter the containerization approach. Wouldn&#8217;t it be great if testing a new version of your chosen software was essentially nothing more than stopping one machine process and starting another? This is one of the many outcomes you can achieve when using containerized services. No longer is there a need to spin up a second (potentially resource hungry) virtual machine (VM) just to find out that you have more work to do before upgrading to a new package release for your software. This also applies to scenarios where a new software release goes south sometime after deployment and you need to quickly find your way back to a known working version.</p>



<p>Not all containers are created equally though! The term container is a bit ambiguous since there are actually different types of containers. For example, if you&#8217;re a Proxmox Virtualization Environment (PVE) user, you may have noticed the containers feature. This refers to what are known as Linux Containers (LXC). These containers are not the same as the containers you might run with Docker or Podman. LXC is a great alternative to using more resource hungry VMs when you don&#8217;t necessarily need the features only found with traditional VMs. A Docker or Podman container is more akin to a convenient development and deployment solution for applications. Think of these container types as a great way to package an application with all of it&#8217;s environmental dependencies to make execution in different hosting environments much smoother. Since it is outside the scope of this article, I will not be going into the vast details regarding the differences between LXC and Docker/Podman containers.</p>



<p>Since this article assumes you&#8217;re a container novice, I will be focusing on the simplest use cases to get you started with containers. This means I will focus on the use of Docker vs Podman even though both have many things in common including a nearly identical command line interface. There are many reasons why one might choose to use one container solution over the other but again, that is outside the scope of this article.</p>



<h2 class="wp-block-heading">Installing Docker Engine</h2>



<p>To get started with running Docker containers, you need to install the Docker Engine. This software package is readily available on many major Linux distributions including both Debian and RHEL based systems. I will be focusing on deployment in a Debian based environment (Ubuntu) in this article. Before beginning, I will assume you have a fresh, unmodified Ubuntu 18.04+ environment with an active shell session using a non-root user that has super user (sudo) privileges.</p>



<p>The first step is to update your environment with all the latest updates for your current distribution release. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>sudo apt update &amp;&amp; sudo apt dist-upgrade -y</code></pre>



<p>The next step is to install a few dependencies that will simplify the remaining steps of the process by condensing some commands into more abstract, non-release specific commands. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>sudo apt install -y ca-certificates curl gnupg lsb-release</code></pre>



<p>Now you need to download and install the Docker repository GPG key to the local key ring. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></pre>



<p>Next you will need to add the appropriate APT package manager configuration so that your system is aware of the Docker repository. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>echo \
  "deb &#91;arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></pre>



<p>Now that the operating system is aware of the Docker repository, you need to update the local APT package cache to include all of the packages available from the Docker repository. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>sudo apt update</code></pre>



<p>Now it&#8217;s time to install the Docker Engine as well as containerd. Containerd is what ultimately runs the containers in this environment while the Docker Engine manages the setup and maintenance of those running containers. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>sudo apt install -y docker-ce docker-ce-cli containerd.io</code></pre>



<p>Now that the Docker Engine is installed, you should override the default network configuration to help ensure the internal networks used for the containers don&#8217;t overlap with your network infrastructure. This step isn&#8217;t fool-proof but will likely be sufficient for the typical production environment that doesn&#8217;t make use of the IANA 192.168.0.0/16 subnet. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>echo '{
  "bip": "192.168.228.1/23",
  "default-address-pools": &#91;{"base":"192.168.230.0/23","size":27}]
}
' | sudo tee /etc/docker/daemon.json &gt; /dev/null</code></pre>



<p>Now the Docker Engine needs restarted in order for the networking changes to take effect. Execute the following command:</p>



<pre class="wp-block-code has-small-font-size"><code>sudo systemctl restart docker</code></pre>



<p>Boom! You&#8217;re ready to start running Docker containers already! It really is that simple! Since you&#8217;re here reading this article, I will assume you&#8217;re not yet a CLI ninja though so you&#8217;ll probably want some sort of graphical user interface (GUI) for managing the containers on this new Docker host. There are some options out there but Portainer is by far the most heavily developed product on the market at the time of writing this article.</p>



<h2 class="wp-block-heading">Installing Portainer GUI</h2>



<p>If you would like to install the latest Portainer version to the server to manage it, execute the following commands:</p>



<pre class="wp-block-code has-small-font-size"><code>export portainer_version=$(curl --silent "https://api.github.com/repos/portainer/portainer/releases/latest" | grep '"tag_name":' | sed -E 's/.*"(&#91;^"]+)".*/\1/')

sudo docker volume create portainer_data

sudo docker run -d -p 8000:8000 -p 9443:9443 --name portainer \
    --restart=always \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v portainer_data:/data \
    portainer/portainer-ce:$portainer_version</code></pre>



<p>If everything worked, this should result in a new GUI ready to use by navigating to https://YOUR-MACHINE-IP-OR-HOSTNAME:9443./ On your first visit, you will be prompted to create a new administrator account to use with the app. Now you&#8217;re really ready to hit the ground running with ninja speed as you start deploying containers!</p>
]]></content:encoded>
					
					<wfw:commentRss>/compute-stacks/deploying-docker-on-ubuntu-20-04/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
